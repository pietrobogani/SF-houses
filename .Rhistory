dim(diff_evictions)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_evictions))
#Plot di funzioni e derivate delle evictions
x11()
plot(funct_data, xlab = 'Year', ylab = 'Number of evictions', main = 'Smoothed functions of evictions')
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Number of evictions)', main = 'Approximation of first derivative')
#Preparo i dati per il modello
library(readr)
library(sf)
geo = read_sf('SFNeighborhoods_new.geojson')
eviction_nhood_monthly <- read_csv("eviction_monthly_nh.csv")
eviction_nhood_monthly = eviction_nhood_monthly[-2251,] #tolgo la riga con il count totale
vect_year = eviction_nhood_monthly$year
vect_month = eviction_nhood_monthly$month
vect_day = rep(1,length(vect_year))
date = paste(vect_year,vect_month,vect_day, sep = '-')
eviction_nhood_monthly$date = date
rm(vect_day,vect_month,vect_year,date)
eviction_nhood_monthly$date = as.Date(eviction_nhood_monthly$date, tryFormats = '%Y-%m-%d')
#typeof(eviction_nhood_monthly$date)
eviction_nhood_monthly$date_num = as.numeric(eviction_nhood_monthly$date)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
print(nh)
print(dim(eviction_nhood_monthly[which(eviction_nhood_monthly$nhood == nh),]))
}
# Rimuovo McLaren Park , Treasure Island e Lincoln Park dato che ho 1 osservazione ...
# Rimuovo anche Golden Gate Park perchè ha una parcel!
nh_multiple_osservations = c('McLaren Park', 'Treasure Island', 'Lincoln Park', 'Golden Gate Park')
for(nh in nh_multiple_osservations){
ind = which(eviction_nhood_monthly$nhood == nh)
eviction_nhood_monthly = eviction_nhood_monthly[-ind,]
}
rm(nh,nh_multiple_osservations, ind)
#Aggiungo l'area di ciascun nhood
eviction_nhood_monthly$area = rep(0,dim(eviction_nhood_monthly)[1])
list_nhood = unique(geo$nhood)
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$area = geo[which(geo$nhood == i),]$area
}
}
#Aggiungo il numero di parcels di ciascun nhood
parcels <- read_csv("Parcels_augmented.csv")
parcels$count = 1
parcels_for_nhood = aggregate(parcels$count , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(parcels_for_nhood$Group.1)
eviction_nhood_monthly$parcels = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$parcels = parcels_for_nhood[which(parcels_for_nhood$Group.1 == i),]$x
}
}
#Aggiungo il numero di residents units di ciasun nhood
resunits_for_nhood = aggregate(parcels$RESUNITS , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(resunits_for_nhood$Group.1)
eviction_nhood_monthly$resunits = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$resunits = resunits_for_nhood[which(resunits_for_nhood$Group.1 == i),]$x
}
}
eviction_nhood_monthly$count_not_norm = eviction_nhood_monthly$count
eviction_nhood_monthly$count = eviction_nhood_monthly$count / eviction_nhood_monthly$parcels
eviction_nhood_monthly$count_parcels = eviction_nhood_monthly$count / eviction_nhood_monthly$parcels
eviction_nhood_monthly$count_resunits = eviction_nhood_monthly$count / eviction_nhood_monthly$resunits
#Plot delle raw evictions (ie non smoothed)
x11()
plot(eviction_nhood_monthly$date,eviction_nhood_monthly$count,
xlab = 'Year', ylab = 'Number of evictions', main = 'Raw number of evictions')
#Creo modello di kern smoothing e preparo i dataset funzionali
first_date = min(eviction_nhood_monthly$date)
final_date = max(eviction_nhood_monthly$date)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funz_evictions = data.frame(row.names = grid_time)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
ind_nh = which(eviction_nhood_monthly$nhood == nh)
data = eviction_nhood_monthly[ind_nh,]
#bw = npregbw(formula = count ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( count ~ date_num,
ckertype = 'gaussian',
bws = 356*6/12,  #bw$bw, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funz_evictions = cbind(funz_evictions,preds$fit)
}
rm(data,nh,ind_nh,m_loc,preds,se.bands)
colnames(funz_evictions) = list_nhood
library(roahd)
funct_data = funz_evictions
funct_data = fData(grid_time,t(funct_data))
#Calcolo derivate prime e creo i dataset
diff_evictions = funz_evictions[2:dim(funz_evictions)[1],] - funz_evictions[1:dim(funz_evictions)[1]-1,]
dim(funz_evictions)
dim(diff_evictions)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_evictions))
#Plot di funzioni e derivate delle evictions
x11()
plot(funct_data, xlab = 'Year', ylab = 'Number of evictions', main = 'Smoothed functions of evictions')
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Number of evictions)', main = 'Approximation of first derivative')
#Preparo i dati per il modello
library(readr)
library(sf)
geo = read_sf('SFNeighborhoods_new.geojson')
eviction_nhood_monthly <- read_csv("eviction_monthly_nh.csv")
eviction_nhood_monthly = eviction_nhood_monthly[-2251,] #tolgo la riga con il count totale
vect_year = eviction_nhood_monthly$year
vect_month = eviction_nhood_monthly$month
vect_day = rep(1,length(vect_year))
date = paste(vect_year,vect_month,vect_day, sep = '-')
eviction_nhood_monthly$date = date
rm(vect_day,vect_month,vect_year,date)
eviction_nhood_monthly$date = as.Date(eviction_nhood_monthly$date, tryFormats = '%Y-%m-%d')
#typeof(eviction_nhood_monthly$date)
eviction_nhood_monthly$date_num = as.numeric(eviction_nhood_monthly$date)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
print(nh)
print(dim(eviction_nhood_monthly[which(eviction_nhood_monthly$nhood == nh),]))
}
# Rimuovo McLaren Park , Treasure Island e Lincoln Park dato che ho 1 osservazione ...
# Rimuovo anche Golden Gate Park perchè ha una parcel!
nh_multiple_osservations = c('McLaren Park', 'Treasure Island', 'Lincoln Park', 'Golden Gate Park')
for(nh in nh_multiple_osservations){
ind = which(eviction_nhood_monthly$nhood == nh)
eviction_nhood_monthly = eviction_nhood_monthly[-ind,]
}
rm(nh,nh_multiple_osservations, ind)
#Aggiungo l'area di ciascun nhood
eviction_nhood_monthly$area = rep(0,dim(eviction_nhood_monthly)[1])
list_nhood = unique(geo$nhood)
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$area = geo[which(geo$nhood == i),]$area
}
}
#Aggiungo il numero di parcels di ciascun nhood
parcels <- read_csv("Parcels_augmented.csv")
parcels$count = 1
parcels_for_nhood = aggregate(parcels$count , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(parcels_for_nhood$Group.1)
eviction_nhood_monthly$parcels = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$parcels = parcels_for_nhood[which(parcels_for_nhood$Group.1 == i),]$x
}
}
#Aggiungo il numero di residents units di ciasun nhood
resunits_for_nhood = aggregate(parcels$RESUNITS , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(resunits_for_nhood$Group.1)
eviction_nhood_monthly$resunits = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$resunits = resunits_for_nhood[which(resunits_for_nhood$Group.1 == i),]$x
}
}
eviction_nhood_monthly$count_not_norm = eviction_nhood_monthly$count
eviction_nhood_monthly$count = eviction_nhood_monthly$count / eviction_nhood_monthly$resunits
eviction_nhood_monthly$count_parcels = eviction_nhood_monthly$count / eviction_nhood_monthly$parcels
eviction_nhood_monthly$count_resunits = eviction_nhood_monthly$count / eviction_nhood_monthly$resunits
#Plot delle raw evictions (ie non smoothed)
x11()
plot(eviction_nhood_monthly$date,eviction_nhood_monthly$count,
xlab = 'Year', ylab = 'Number of evictions', main = 'Raw number of evictions')
#Creo modello di kern smoothing e preparo i dataset funzionali
first_date = min(eviction_nhood_monthly$date)
final_date = max(eviction_nhood_monthly$date)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funz_evictions = data.frame(row.names = grid_time)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
ind_nh = which(eviction_nhood_monthly$nhood == nh)
data = eviction_nhood_monthly[ind_nh,]
#bw = npregbw(formula = count ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( count ~ date_num,
ckertype = 'gaussian',
bws = 356*6/12,  #bw$bw, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funz_evictions = cbind(funz_evictions,preds$fit)
}
rm(data,nh,ind_nh,m_loc,preds,se.bands)
colnames(funz_evictions) = list_nhood
library(roahd)
funct_data = funz_evictions
funct_data = fData(grid_time,t(funct_data))
#Calcolo derivate prime e creo i dataset
diff_evictions = funz_evictions[2:dim(funz_evictions)[1],] - funz_evictions[1:dim(funz_evictions)[1]-1,]
dim(funz_evictions)
dim(diff_evictions)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_evictions))
#Plot di funzioni e derivate delle evictions
x11()
plot(funct_data, xlab = 'Year', ylab = 'Number of evictions', main = 'Smoothed functions of evictions')
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Number of evictions)', main = 'Approximation of first derivative')
# fbplot(funct_data) da errori...bisogna usare la griglia di numeri e non di date!
funct_data_num = fData(grid_time_num$date_num,t(funz_evictions))
fbplot = fbplot(funct_data_num, main = 'Functional box-plot for functions of evictions')
fbplot$ID_outliers
x11()
out_funct <- outliergram(funct_data)
#Preparo i dati per il modello
library(readr)
library(sf)
geo = read_sf('SFNeighborhoods_new.geojson')
eviction_nhood_monthly <- read_csv("eviction_monthly_nh.csv")
eviction_nhood_monthly = eviction_nhood_monthly[-2251,] #tolgo la riga con il count totale
vect_year = eviction_nhood_monthly$year
vect_month = eviction_nhood_monthly$month
vect_day = rep(1,length(vect_year))
date = paste(vect_year,vect_month,vect_day, sep = '-')
eviction_nhood_monthly$date = date
rm(vect_day,vect_month,vect_year,date)
eviction_nhood_monthly$date = as.Date(eviction_nhood_monthly$date, tryFormats = '%Y-%m-%d')
#typeof(eviction_nhood_monthly$date)
eviction_nhood_monthly$date_num = as.numeric(eviction_nhood_monthly$date)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
print(nh)
print(dim(eviction_nhood_monthly[which(eviction_nhood_monthly$nhood == nh),]))
}
# Rimuovo McLaren Park , Treasure Island e Lincoln Park dato che ho 1 osservazione ...
# Rimuovo anche Golden Gate Park perchè ha una parcel!
nh_multiple_osservations = c('McLaren Park', 'Treasure Island', 'Lincoln Park', 'Golden Gate Park')
for(nh in nh_multiple_osservations){
ind = which(eviction_nhood_monthly$nhood == nh)
eviction_nhood_monthly = eviction_nhood_monthly[-ind,]
}
rm(nh,nh_multiple_osservations, ind)
#Aggiungo l'area di ciascun nhood
eviction_nhood_monthly$area = rep(0,dim(eviction_nhood_monthly)[1])
list_nhood = unique(geo$nhood)
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$area = geo[which(geo$nhood == i),]$area
}
}
#Aggiungo il numero di parcels di ciascun nhood
parcels <- read_csv("Parcels_augmented.csv")
parcels$count = 1
parcels_for_nhood = aggregate(parcels$count , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(parcels_for_nhood$Group.1)
eviction_nhood_monthly$parcels = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$parcels = parcels_for_nhood[which(parcels_for_nhood$Group.1 == i),]$x
}
}
#Aggiungo il numero di residents units di ciasun nhood
resunits_for_nhood = aggregate(parcels$RESUNITS , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(resunits_for_nhood$Group.1)
eviction_nhood_monthly$resunits = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$resunits = resunits_for_nhood[which(resunits_for_nhood$Group.1 == i),]$x
}
}
#NB: da qui in poi (per non dover riscrivere tutto il codice!) si avrà:
#    - count = #evictions/area
#    - count_not_norm = #evictions
#    - count_parcels = #evictions/#parcels
#    - count_resunits = #evictions/#resunits
eviction_nhood_monthly$count_not_norm = eviction_nhood_monthly$count
eviction_nhood_monthly$count = eviction_nhood_monthly$count # / eviction_nhood_monthly$resunits
eviction_nhood_monthly$count_parcels = eviction_nhood_monthly$count / eviction_nhood_monthly$parcels
eviction_nhood_monthly$count_resunits = eviction_nhood_monthly$count / eviction_nhood_monthly$resunits
#Plot delle raw evictions (ie non smoothed)
x11()
plot(eviction_nhood_monthly$date,eviction_nhood_monthly$count,
xlab = 'Year', ylab = 'Number of evictions', main = 'Raw number of evictions')
#Creo modello di kern smoothing e preparo i dataset funzionali
first_date = min(eviction_nhood_monthly$date)
final_date = max(eviction_nhood_monthly$date)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funz_evictions = data.frame(row.names = grid_time)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
ind_nh = which(eviction_nhood_monthly$nhood == nh)
data = eviction_nhood_monthly[ind_nh,]
#bw = npregbw(formula = count ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( count ~ date_num,
ckertype = 'gaussian',
bws = 356*6/12,  #bw$bw, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funz_evictions = cbind(funz_evictions,preds$fit)
}
rm(data,nh,ind_nh,m_loc,preds,se.bands)
colnames(funz_evictions) = list_nhood
library(roahd)
funct_data = funz_evictions
funct_data = fData(grid_time,t(funct_data))
#Calcolo derivate prime e creo i dataset
diff_evictions = funz_evictions[2:dim(funz_evictions)[1],] - funz_evictions[1:dim(funz_evictions)[1]-1,]
dim(funz_evictions)
dim(diff_evictions)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_evictions))
#Plot di funzioni e derivate delle evictions
x11()
plot(funct_data, xlab = 'Year', ylab = 'Number of evictions', main = 'Smoothed functions of evictions')
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Number of evictions)', main = 'Approximation of first derivative')
#Preparo i dati per il modello
library(readr)
library(sf)
geo = read_sf('SFNeighborhoods_new.geojson')
eviction_nhood_monthly <- read_csv("eviction_monthly_nh.csv")
eviction_nhood_monthly = eviction_nhood_monthly[-2251,] #tolgo la riga con il count totale
vect_year = eviction_nhood_monthly$year
vect_month = eviction_nhood_monthly$month
vect_day = rep(1,length(vect_year))
date = paste(vect_year,vect_month,vect_day, sep = '-')
eviction_nhood_monthly$date = date
rm(vect_day,vect_month,vect_year,date)
eviction_nhood_monthly$date = as.Date(eviction_nhood_monthly$date, tryFormats = '%Y-%m-%d')
#typeof(eviction_nhood_monthly$date)
eviction_nhood_monthly$date_num = as.numeric(eviction_nhood_monthly$date)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
print(nh)
print(dim(eviction_nhood_monthly[which(eviction_nhood_monthly$nhood == nh),]))
}
# Rimuovo McLaren Park , Treasure Island e Lincoln Park dato che ho 1 osservazione ...
# Rimuovo anche Golden Gate Park perchè ha una parcel!
nh_multiple_osservations = c('McLaren Park', 'Treasure Island', 'Lincoln Park', 'Golden Gate Park')
for(nh in nh_multiple_osservations){
ind = which(eviction_nhood_monthly$nhood == nh)
eviction_nhood_monthly = eviction_nhood_monthly[-ind,]
}
rm(nh,nh_multiple_osservations, ind)
#Aggiungo l'area di ciascun nhood
eviction_nhood_monthly$area = rep(0,dim(eviction_nhood_monthly)[1])
list_nhood = unique(geo$nhood)
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$area = geo[which(geo$nhood == i),]$area
}
}
#Aggiungo il numero di parcels di ciascun nhood
parcels <- read_csv("Parcels_augmented.csv")
parcels$count = 1
parcels_for_nhood = aggregate(parcels$count , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(parcels_for_nhood$Group.1)
eviction_nhood_monthly$parcels = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$parcels = parcels_for_nhood[which(parcels_for_nhood$Group.1 == i),]$x
}
}
#Aggiungo il numero di residents units di ciasun nhood
resunits_for_nhood = aggregate(parcels$RESUNITS , by = list(parcels$neighborhoods), FUN = sum)
list_nhood = unique(resunits_for_nhood$Group.1)
eviction_nhood_monthly$resunits = rep(0,dim(eviction_nhood_monthly)[1])
for(i in list_nhood){
ind_eviction_nhood = which(eviction_nhood_monthly$nhood == i)
if(length(ind_eviction_nhood) > 0){
eviction_nhood_monthly[ind_eviction_nhood,]$resunits = resunits_for_nhood[which(resunits_for_nhood$Group.1 == i),]$x
}
}
eviction_nhood_monthly$count_not_norm = eviction_nhood_monthly$count
eviction_nhood_monthly$count = eviction_nhood_monthly$count / eviction_nhood_monthly$area
eviction_nhood_monthly$count_parcels = eviction_nhood_monthly$count / eviction_nhood_monthly$parcels
eviction_nhood_monthly$count_resunits = eviction_nhood_monthly$count / eviction_nhood_monthly$resunits
#Plot delle raw evictions (ie non smoothed)
x11()
plot(eviction_nhood_monthly$date,eviction_nhood_monthly$count,
xlab = 'Year', ylab = 'Number of evictions', main = 'Raw number of evictions')
#Creo modello di kern smoothing e preparo i dataset funzionali
first_date = min(eviction_nhood_monthly$date)
final_date = max(eviction_nhood_monthly$date)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funz_evictions = data.frame(row.names = grid_time)
list_nhood = unique(eviction_nhood_monthly$nhood)
for(nh in list_nhood){
ind_nh = which(eviction_nhood_monthly$nhood == nh)
data = eviction_nhood_monthly[ind_nh,]
#bw = npregbw(formula = count ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( count ~ date_num,
ckertype = 'gaussian',
bws = 356*6/12,  #bw$bw, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funz_evictions = cbind(funz_evictions,preds$fit)
}
rm(data,nh,ind_nh,m_loc,preds,se.bands)
colnames(funz_evictions) = list_nhood
library(roahd)
funct_data = funz_evictions
funct_data = fData(grid_time,t(funct_data))
#Calcolo derivate prime e creo i dataset
diff_evictions = funz_evictions[2:dim(funz_evictions)[1],] - funz_evictions[1:dim(funz_evictions)[1]-1,]
dim(funz_evictions)
dim(diff_evictions)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_evictions))
#Plot di funzioni e derivate delle evictions
x11()
plot(funct_data, xlab = 'Year', ylab = 'Number of evictions', main = 'Smoothed functions of evictions')
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Number of evictions)', main = 'Approximation of first derivative')
#MBD,mediana e boxplot per evictions funzionali
modified_band_depth_rent = MBD(funct_data)
print(paste('The nhood with max depth is:', colnames(funz_evictions)[which.max(modified_band_depth_rent)] ))
median_curve_rent = median_fData(fData = funct_data, type = 'MBD' )
x11()
plot(funct_data, xlab = 'Year', ylab = 'Number of evictions', main = 'Smoothed functions of evictions with median (wrt MBD)')
plot(median_curve_rent, col = 'red', lwd = 3, add = T)
# fbplot(funct_data) da errori...bisogna usare la griglia di numeri e non di date!
funct_data_num = fData(grid_time_num$date_num,t(funz_evictions))
fbplot = fbplot(funct_data_num, main = 'Functional box-plot for functions of evictions')
fbplot$ID_outliers
x11()
out_funct <- outliergram(funct_data)
x11()
par(mfrow=c(1,2))
plot(funct_data, xlab = 'Year',ylab = 'Number of evictions', main = 'Smoothed functions of evictions')
plot(funct_data_diff,xlab = 'Year', ylab = 'd/dt(Number of evictions', main = 'Approximation of first derivatives')
#MBD,mediana e boxplot per derivate di evictions
modified_band_depth_rent_diff = MBD(funct_data_diff)
print(paste('The nhood with max depth is:', colnames(funz_evictions)[which.max(modified_band_depth_rent_diff)] ))
median_curve_rent_diff = median_fData(fData = funct_data_diff, type = 'MBD' )
x11()
plot(funct_data_diff,xlab = 'Year', ylab = 'd/dt(Number of evictions)', main = 'Approximation of first derivative with median (wrt MBD)')
plot(median_curve_rent_diff, col = 'red', lwd = 3, add = T)
x11()
#fbplot(funct_data_diff) da errori... perch??
funct_data_diff_num = fData(grid_time_num$date_num[2:dim(grid_time_num)[1]],t(diff_evictions))
fbplot(funct_data_diff_num, main = 'Functional box-plot for first derivative of evictions')
out_funct_diff <- outliergram(funct_data_diff) #Non ha alcun senso...
fbplot(funct_data_diff_num, main = 'Functional box-plot for first derivative of evictions')
#Provo a fare smoothing con kernel regr sui rent
{
library(ISLR2)
library(car)
library(np)
library(splines)
library(fda)
library(magrittr)
library(KernSmooth)
library(readr)
library(stringr)
rent_clean <- read_csv("rent_clean_nh.csv")
aus_df <- data.frame(year = as.numeric(format(rent_clean$d, format = "%Y")),
month = as.numeric(format(rent_clean$d, format = "%m")),
day = as.numeric(format(rent_clean$d, format = "%d")))
rent_clean = cbind(rent_clean,aus_df)
rm(aus_df)
rent_clean = rent_clean[which(rent_clean$year >= 2011 & rent_clean$year <= 2018),]
ind_typo = which(rent_clean$price_mq > 175) #la media in quel nhood e anno ? 10 volte meno...typo?
rent_clean = rent_clean[-c(ind_typo),]
#vect_date_num = as.numeric(paste(rent_clean$year,rent_clean$month,rent_clean$day, sep = ''))
#rent_clean = cbind(rent_clean,vect_date_num)
rent_clean$date_num = as.numeric(rent_clean$d)
x11()
plot(rent_clean$d,rent_clean$price_mq,xlab = 'Year',ylab = 'Price/mq',ylim = c(0,150), main = 'Raw rents',cex = 0.5)
list_nhood = unique(rent_clean$nhood)
first_date = min(rent_clean$d)
final_date = max(rent_clean$d)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funct_data = data.frame(row.names = grid_time)
for(nh in list_nhood){
ind_nh = which(rent_clean$nhood == nh)
data = rent_clean[ind_nh,]
#bw = npregbw(formula = price_mq ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( price_mq ~ date_num,
ckertype = 'gaussian',
bws = 365*6/12, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funct_data = cbind(funct_data,preds$fit)
}
rm(nh, data,m_loc,preds,se.bands,ind_nh)
colnames(funct_data) = list_nhood
dim(funct_data)
length(grid_time)
library(roahd)
funz_rent = funct_data
funct_data = fData(grid_time,t(funct_data))
x11()
plot(funct_data, xlab = 'Year', ylab = 'Price/mq', main = 'Smoothed rent functions')
#Calcolo derivate prime
diff_rent = funz_rent[2:dim(funz_rent)[1],] - funz_rent[1:dim(funz_rent)[1]-1,]
dim(funz_rent)
dim(diff_rent)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_rent))
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Price/mq)', main = 'Approximation of first derivative of rent functions')
}
