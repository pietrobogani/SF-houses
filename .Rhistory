# The model we have to test is the following:
# km = mu + alpha*station + beta*fuel + gamma*station*fuel
# We have 3 different tests:
# 1. factor station   (H0: alpha=0)
# 2. factor fuel      (H0: beta=0)
# 3. interaction      (H0: gamma=0)
# We apply different permutations for developing the different tests!
# We start by testing the interaction:
# H0: gamma=0 against H_1: gamma!=0
# test statistic:
summary.aov(aov(km ~ station + fuel + station:fuel))
T0_station_fuel <- summary.aov(aov(km ~ station + fuel + station:fuel))[[1]][3,4]
T0_station_fuel
# permutation
# the idea is to permute the residuals under H0:
# km = mu + alpha*station + beta*fuel
# additive model
aov.H0station_fuel <- aov(km ~ station + fuel)
aov.H0station_fuel
residuals.H0station_fuel <- aov.H0station_fuel$residuals
n <- 8
permutation <- sample(1:n)
residuals.H0station_fuel <- residuals.H0station_fuel[permutation]
# permuted y values:
km.perm.H0station_fuel <- aov.H0station_fuel$fitted + residuals.H0station_fuel
summary.aov(aov(km.perm.H0station_fuel ~ station + fuel + station:fuel))
# How data has changed?
layout(rbind(1:2))
plot(station_fuel, km, col=rainbow(5)[2:5], ylim=c(0,24),main='Original data')
plot(station_fuel, km.perm.H0station_fuel, col=rainbow(5)[2:5], ylim=c(0,24),main='Permuted data')
# TEST of interaction
B <- 1000
T_station_fuel <- numeric(B)
for(perm in 1:B){
permutation <- sample(n)
residuals.H0station_fuel <- residuals.H0station_fuel[permutation]
km.perm.H0station_fuel <- aov.H0station_fuel$fitted + residuals.H0station_fuel
T_station_fuel[perm] <- summary.aov(aov(km.perm.H0station_fuel ~ station + fuel + station:fuel))[[1]][3,4]
}
# p-value
sum(T_station_fuel >= T0_station_fuel)/B
######################################################################?
# Two-way ANOVA (Pb. 4, 14/09/06)
# Variable:  Distance     [km/l]
# factor1:   Fuel station (0=Esso, 1=Shell)
# factor2:   Type of fuel (0=95,   1=98)
km          <- c(18.7, 16.8, 20.1, 22.4, 14.0, 15.2, 22.0, 23.3)
station     <- factor(c('Esso','Esso','Esso','Esso','Shell','Shell','Shell','Shell'))
fuel        <- factor(c('95','95','98','98','95','95','98','98'))
station_fuel<- factor(c('Esso95','Esso95','Esso98','Esso98','Shell95','Shell95','Shell98','Shell98'))
M             <- mean(km)
Mstation      <- tapply(km,      station, mean)
Mfuel         <- tapply(km,       fuel, mean)
Mstation_fuel <- tapply(km, station_fuel, mean)
plot(station_fuel, km, col=rainbow(5)[2:5], ylim=c(0,24))
# Parametric test:
summary.aov(aov(km ~ station + fuel + station:fuel))
# Without interaction
summary.aov(aov(km ~ station + fuel))
# Without station
summary.aov(aov(km ~ fuel))
# Permutation test
# The model we have to test is the following:
# km = mu + alpha*station + beta*fuel + gamma*station*fuel
# We have 3 different tests:
# 1. factor station   (H0: alpha=0)
# 2. factor fuel      (H0: beta=0)
# 3. interaction      (H0: gamma=0)
# We apply different permutations for developing the different tests!
# We start by testing the interaction:
# H0: gamma=0 against H_1: gamma!=0
# test statistic:
summary.aov(aov(km ~ station + fuel + station:fuel))
T0_station_fuel <- summary.aov(aov(km ~ station + fuel + station:fuel))[[1]][3,4]
T0_station_fuel
# permutation
# the idea is to permute the residuals under H0:
# km = mu + alpha*station + beta*fuel
# additive model
aov.H0station_fuel <- aov(km ~ station + fuel)
aov.H0station_fuel
residuals.H0station_fuel <- aov.H0station_fuel$residuals
n <- 8
permutation <- sample(1:n)
residuals.H0station_fuel <- residuals.H0station_fuel[permutation]
# permuted y values:
km.perm.H0station_fuel <- aov.H0station_fuel$fitted + residuals.H0station_fuel
summary.aov(aov(km.perm.H0station_fuel ~ station + fuel + station:fuel))
# How data has changed?
layout(rbind(1:2))
plot(station_fuel, km, col=rainbow(5)[2:5], ylim=c(0,24),main='Original data')
plot(station_fuel, km.perm.H0station_fuel, col=rainbow(5)[2:5], ylim=c(0,24),main='Permuted data')
# TEST of interaction
B <- 1000
T_station_fuel <- numeric(B)
for(perm in 1:B){
permutation <- sample(n)
residuals.H0station_fuel <- residuals.H0station_fuel[permutation]
km.perm.H0station_fuel <- aov.H0station_fuel$fitted + residuals.H0station_fuel
T_station_fuel[perm] <- summary.aov(aov(km.perm.H0station_fuel ~ station + fuel + station:fuel))[[1]][3,4]
}
# p-value
sum(T_station_fuel >= T0_station_fuel)/B
# The interaction is not significant.
# We can remove it and perform a test for the two main effects
# TEST OF FACTOR STATION   (H0: alpha=0)
T0_station <- summary.aov(aov(km ~ station + fuel))[[1]][1,4]
# residuals under H0:
# km = mu + beta*fuel
aov.H0station <- aov(km ~ fuel)
residuals.H0station <- aov.H0station$residuals
# permuted y values:
km.perm.H0station <- aov.H0station$fitted + residuals.H0station[permutation]
summary.aov(aov(km.perm.H0station ~ station + fuel))
# How data has changed?
layout(rbind(1:2))
plot(station_fuel, km, col=rainbow(5)[2:5], ylim=c(0,24),main='Original data')
plot(station_fuel, km.perm.H0station, col=rainbow(5)[2:5], ylim=c(0,24),main='Permuted data')
# TEST OF FACTOR FUEL   (H0: beta=0)
T0_fuel <- summary.aov(aov(km ~ station + fuel))[[1]][2,4]
# residuals under H0:
# km = mu + alpha*station
aov.H0fuel <- aov(km ~ station)
residuals.H0fuel <- aov.H0fuel$residuals
# permuted y values:
km.perm.H0fuel <- aov.H0fuel$fitted + residuals.H0fuel[permutation]
summary.aov(aov(km.perm.H0fuel ~ station + fuel))
# How data has changed?
layout(rbind(1:2))
plot(station_fuel, km, col=rainbow(5)[2:5], ylim=c(0,24),main='Original data')
plot(station_fuel, km.perm.H0fuel, col=rainbow(5)[2:5], ylim=c(0,24),main='Permuted data')
# TEST OF FACTOR STATION ANF TEST OF FACTOR FUEL
# p-values
B <- 1000
T_fuel <- T_station <- numeric(B)
for(perm in 1:B){
permutation <- sample(n)
km.perm.H0station <- aov.H0station$fitted + residuals.H0station[permutation]
T_station[perm] <- summary.aov(aov(km.perm.H0station ~ station + fuel))[[1]][1,4]
km.perm.H0fuel <- aov.H0fuel$fitted + residuals.H0fuel[permutation]
T_fuel[perm] <- summary.aov(aov(km.perm.H0fuel ~ station + fuel))[[1]][2,4]
}
sum(T_station >= T0_station)/B
sum(T_fuel >= T0_fuel)/B
rent_clean <- read.csv("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/rent_clean_nh.csv", header=TRUE)
#-- TESTIAMO ORA CON UNA ANOVA TWO-WAY. I GRUPPI ORA SONO DEFINITI DA nhood & year
rent <- rent_clean[,c(3,9,11)]
rent$year.nhood <- NA
for (i in 1: length(rent[,1])){
rent$year.nhood[i] <-paste(rent$year[i], rent$nhood[i],  sep=" ")
}
rent <- rent[order(rent$year.nhood),]
g <- length(levels(factor(rent$nhood)))
b <- length(levels(factor(rent$year)))
year_nhood <- factor(rent$year.nhood)
new <-factor(rent$year.nhood )
nnew <- rent$price_mq
means <-with(rent, tapply(rent$price_mq, year_nhood, mean))
means
plot(new, nnew,  ylim=c(10,100))
points(unique(year_nhood), means, col="green", pch=19)
B = 1000
seed = 26111992
set.seed(seed)
M           <- mean(rent$price_mq)
Mnhood    <- tapply(rent$price_mq,rent$nhood, mean)
Myear     <- tapply(rent$price_mq,rent$year, mean)
### X.ijk = mu + alpha.i + beta.j + gamma.ij + eps.ijk;     eps.ijk~N(0,sigma^2)
#I need to test alpha.i=0 ,beta.j=0 ,gamma.ij =0 one at a time    |  i = 1,...,g , j = 1,...,b
# H0:gamma.ij = 0   vs   H1: gamma.ij != 0 (i.e. can I remove the interaction?)
summary.aov(aov(rent$price_mq ~ rent$nhood + rent$year + rent$nhood:rent$year))
T0_nhood.year <- summary.aov(aov(rent$price_mq ~rent$nhood + rent$year + rent$nhood:rent$year))[[1]][3,4] #I need to extract the F-value associated with rent$nhood:rent$year
T0_nhood.year
aov.H0nhood.year <- aov(rent$price_mq ~ rent$nhood + rent$year)
aov.H0nhood.year
residuals.H0nhood.year <- aov.H0nhood.year$residuals
n = length(rent[,1])
T_nhood.year <- numeric(B)
for(perm in 1:B){
permutation <- sample(n)
residuals.H0nhood.year <- residuals.H0nhood.year[permutation]
price_mq.perm.H0nhood.year <- aov.H0nhood.year$fitted + residuals.H0nhood.year
T_nhood.year[perm] <- summary.aov(aov(price_mq.perm.H0nhood.year ~  rent$nhood + rent$year + rent$nhood:rent$year))[[1]][3,4]
}
pval_nhood.year = sum(T_nhood.year >= T0_nhood.year)/B
#Low p-value, I keep the interaction and I go on testing the other 2 one at a time.
pval_nhood.year
# H0:alpha.i = 0   vs   H1: alpha.i != 0 (i.e. can I remove the nhood effect?)
T0_nhood <- summary.aov(aov(rent$price_mq ~rent$nhood + rent$year + rent$nhood:rent$year))[[1]][1,4] #I need to extract the F-value associated with rent$nhood. I put here the complete model
aov.H0nhood <- aov(rent$price_mq ~ rent$year + rent$nhood:rent$year)
residuals.H0nhood <- aov.H0nhood$residuals
T_nhood <- numeric(B)
for(perm in 1:B){
permutation <- sample(n)
price_mq.perm.H0nhood <- aov.H0nhood$fitted + residuals.H0nhood[permutation]
T_nhood[perm] <- summary.aov(aov( price_mq.perm.H0nhood ~ rent$nhood + rent$year+ rent$nhood:rent$year))[[1]][1,4]  #I put here the complete model
}
pval_nhood = sum(T_nhood >= T0_nhood)/B
#high p-value. I remov
pval_nhood
T0_year <- summary.aov(aov(rent$price_mq ~  rent$nhood:rent$year + rent$year))[[1]][2,4] #I need to extract the F-value associated with rent$year. #I put here the complete model
aov.H0year <- aov(rent$price_mq ~ rent$nhood:rent$year)
residuals.H0year <- aov.H0year$residuals
T_year <- numeric(B)
for(perm in 1:B){
permutation <- sample(n)
price_mq.perm.H0year <- aov.H0year$fitted + residuals.H0year[permutation]
T_year[perm] <- summary.aov(aov(price_mq.perm.H0year ~  rent$year + rent$nhood:rent$year))[[1]][2,4] #I put here the complete model
}
pval_year = sum(T_year >= T0_year)/B
pval_year
rent_nhood_yearly <- read.csv("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/rent_nhood_yearly_nh.csv", header=TRUE)
View(rent_nhood_yearly)
rent_clean <- read.csv("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/rent_clean_nh.csv", header=TRUE)
#Provo a fare smoothing con kernel regr sui rent
{
library(ISLR2)
library(car)
library(np)
library(splines)
library(fda)
library(magrittr)
library(KernSmooth)
library(readr)
library(stringr)
rent_clean <- read_csv("rent_clean_nh.csv")
aus_df <- data.frame(year = as.numeric(format(rent_clean$d, format = "%Y")),
month = as.numeric(format(rent_clean$d, format = "%m")),
day = as.numeric(format(rent_clean$d, format = "%d")))
rent_clean = cbind(rent_clean,aus_df)
rm(aus_df)
rent_clean = rent_clean[which(rent_clean$year >= 2011 & rent_clean$year <= 2018),]
ind_typo = which(rent_clean$price_mq > 175) #la media in quel nhood e anno è 10 volte meno...typo?
rent_clean = rent_clean[-c(ind_typo),]
#vect_date_num = as.numeric(paste(rent_clean$year,rent_clean$month,rent_clean$day, sep = ''))
#rent_clean = cbind(rent_clean,vect_date_num)
rent_clean$date_num = as.numeric(rent_clean$d)
x11()
plot(rent_clean$d,rent_clean$price_mq,xlab = 'Year',ylab = 'Price/mq',ylim = c(0,150), main = 'Raw rents',cex = 0.5)
list_nhood = unique(rent_clean$nhood)
first_date = min(rent_clean$d)
final_date = max(rent_clean$d)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funct_data = data.frame(row.names = grid_time)
for(nh in list_nhood){
ind_nh = which(rent_clean$nhood == nh)
data = rent_clean[ind_nh,]
#bw = npregbw(formula = price_mq ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( price_mq ~ date_num,
ckertype = 'gaussian',
bws = 365*6/12, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funct_data = cbind(funct_data,preds$fit)
}
rm(nh, data,m_loc,preds,se.bands,ind_nh)
colnames(funct_data) = list_nhood
dim(funct_data)
length(grid_time)
library(roahd)
funz_rent = funct_data
funct_data = fData(grid_time,t(funct_data))
x11()
plot(funct_data, xlab = 'Year', ylab = 'Price/mq', main = 'Smoothed rent functions')
#Calcolo derivate prime
diff_rent = funz_rent[2:dim(funz_rent)[1],] - funz_rent[1:dim(funz_rent)[1]-1,]
dim(funz_rent)
dim(diff_rent)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_rent))
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Price/mq)', main = 'Approximation of first derivative of rent functions')
}
setwd("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses")
#Provo a fare smoothing con kernel regr sui rent
{
library(ISLR2)
library(car)
library(np)
library(splines)
library(fda)
library(magrittr)
library(KernSmooth)
library(readr)
library(stringr)
rent_clean <- read_csv("rent_clean_nh.csv")
aus_df <- data.frame(year = as.numeric(format(rent_clean$d, format = "%Y")),
month = as.numeric(format(rent_clean$d, format = "%m")),
day = as.numeric(format(rent_clean$d, format = "%d")))
rent_clean = cbind(rent_clean,aus_df)
rm(aus_df)
rent_clean = rent_clean[which(rent_clean$year >= 2011 & rent_clean$year <= 2018),]
ind_typo = which(rent_clean$price_mq > 175) #la media in quel nhood e anno è 10 volte meno...typo?
rent_clean = rent_clean[-c(ind_typo),]
#vect_date_num = as.numeric(paste(rent_clean$year,rent_clean$month,rent_clean$day, sep = ''))
#rent_clean = cbind(rent_clean,vect_date_num)
rent_clean$date_num = as.numeric(rent_clean$d)
x11()
plot(rent_clean$d,rent_clean$price_mq,xlab = 'Year',ylab = 'Price/mq',ylim = c(0,150), main = 'Raw rents',cex = 0.5)
list_nhood = unique(rent_clean$nhood)
first_date = min(rent_clean$d)
final_date = max(rent_clean$d)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funct_data = data.frame(row.names = grid_time)
for(nh in list_nhood){
ind_nh = which(rent_clean$nhood == nh)
data = rent_clean[ind_nh,]
#bw = npregbw(formula = price_mq ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( price_mq ~ date_num,
ckertype = 'gaussian',
bws = 365*6/12, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funct_data = cbind(funct_data,preds$fit)
}
rm(nh, data,m_loc,preds,se.bands,ind_nh)
colnames(funct_data) = list_nhood
dim(funct_data)
length(grid_time)
library(roahd)
funz_rent = funct_data
funct_data = fData(grid_time,t(funct_data))
x11()
plot(funct_data, xlab = 'Year', ylab = 'Price/mq', main = 'Smoothed rent functions')
#Calcolo derivate prime
diff_rent = funz_rent[2:dim(funz_rent)[1],] - funz_rent[1:dim(funz_rent)[1]-1,]
dim(funz_rent)
dim(diff_rent)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_rent))
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Price/mq)', main = 'Approximation of first derivative of rent functions')
}
colnames(funz_rent)[28]
funz_rent = funz_rent[,-28]
diff_rent = diff_rent[,-28]
funct_data = fData(grid_time,t(funz_rent))
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_rent))
library(fdatest)
#NB: data si assume con tempo sulle righe e nomi sulle colonne
data = funz_rent #cambiare con funz_rent per fare i test sulle funzioni dei rent e non derivate!
low_evictions_nhood2 <- read_csv("2 Clusters of nhood based on Evictions/low_evictions_nhood_nh2.csv")
high_evictions_nhood2 <- read_csv("2 Clusters of nhood based on Evictions/high_evictions_nhood_nh2.csv")
low_construction_nhood2_nh <- read_csv("2 Clusters of nhood based on Constructions/low_construction_nhood2_nh.csv")
high_construction_nhood2_nh <- read_csv("2 Clusters of nhood based on Constructions/high_construction_nhood2_nh.csv")
list_low_constr = as.vector(low_construction_nhood2_nh$x)
list_low_constr = list_low_constr[-c(5,7)] #tolgo i nhood non osservati in rent
list_high_constr = as.vector(high_construction_nhood2_nh$x)
list_high_constr = list_high_constr[-c(3,10)]
list_low_evict = as.vector(low_evictions_nhood2$x)
list_high_evict = as.vector(high_evictions_nhood2$x)
list_low_evict = list_low_evict[-c(4,6,7,8,12,16)]#non ci sono osservazioni negli annunci di questi quindi rimuovo
list_high_evict = list_high_evict[-c(3,7)] #non ci sono osservazioni negli annunci quindi tolgo
data1 = data[,list_low_constr]
data2 = data[,list_high_constr]
#data1 = data[,1:23]
#data2 = data[,24:46]
data_bind = rbind(t(data1),t(data2)) #data_bind ha nomi sulle righe!
n = nrow(data_bind)
n1 = nrow(t(data1)) #numero nomi in gruppo1
n2 = nrow(t(data2)) #numero nomi in gruppo2
data1 = fData(grid_time,t(data1)) #partizione di quartieri 1, NB: mettere grid_time se si testano funzioni dei rent
data2 = fData(grid_time,t(data2)) #partizione di quartieri 2, NB: mettere grid_time se si testano funzioni dei rent
seed=2781991
set.seed(seed)
B=1000
mean_diff = median_fData(data1, type = 'MBD') - median_fData(data2, type = 'MBD')
plot(mean_diff)
T0 = sum(abs(mean_diff$values))
T0
data_fd = append_fData(data1,data2)
T0_perm = numeric(B)
x11()
plot(data1, col = 'red', xlab = 'Year', ylab = 'Price/mq',ylim = c(15,70), main = 'Rent functions')
plot(data2, col = 'black', add = T)
legend('topleft', legend=c("Low evictions", "High evictions"),
col=c("red", "black"),lty = 1, cex=0.8)
library(progress)
pb <- progress_bar$new(format = "  processing [:bar] :percent eta: :eta",total = B, clear = FALSE)
for(perm in 1:B){
permutazione <- sample(n)
data_perm=data_fd[permutazione,]
perm1 = data_perm[1:n1,]
perm2 = data_perm[(n2+1):n,]
mean_diff=median_fData(perm1,type='MBD')-median_fData(perm2,type='MBD')
T0_perm[perm]=sum(abs(mean_diff$values))
pb$tick()
}
sum(T0_perm >= T0)/B
hist(T0_perm)
abline(v=T0,col='green')
library(fdatest)
#Provo a fare smoothing con kernel regr sui rent
{
library(ISLR2)
library(car)
library(np)
library(splines)
library(fda)
library(magrittr)
library(KernSmooth)
library(readr)
library(stringr)
rent_clean <- read_csv("rent_clean_nh.csv")
aus_df <- data.frame(year = as.numeric(format(rent_clean$d, format = "%Y")),
month = as.numeric(format(rent_clean$d, format = "%m")),
day = as.numeric(format(rent_clean$d, format = "%d")))
rent_clean = cbind(rent_clean,aus_df)
rm(aus_df)
rent_clean = rent_clean[which(rent_clean$year >= 2011 & rent_clean$year <= 2018),]
ind_typo = which(rent_clean$price_mq > 175) #la media in quel nhood e anno è 10 volte meno...typo?
rent_clean = rent_clean[-c(ind_typo),]
#vect_date_num = as.numeric(paste(rent_clean$year,rent_clean$month,rent_clean$day, sep = ''))
#rent_clean = cbind(rent_clean,vect_date_num)
rent_clean$date_num = as.numeric(rent_clean$d)
x11()
plot(rent_clean$d,rent_clean$price_mq,xlab = 'Year',ylab = 'Price/mq',ylim = c(0,150), main = 'Raw rents',cex = 0.5)
list_nhood = unique(rent_clean$nhood)
first_date = min(rent_clean$d)
final_date = max(rent_clean$d)
grid_time = seq(first_date,final_date,by = 1)
grid_time_num = data.frame(date_num = as.numeric(grid_time))
funct_data = data.frame(row.names = grid_time)
for(nh in list_nhood){
ind_nh = which(rent_clean$nhood == nh)
data = rent_clean[ind_nh,]
#bw = npregbw(formula = price_mq ~ date_num, bws = 365*6/12, data = data)
m_loc = npreg( price_mq ~ date_num,
ckertype = 'gaussian',
bws = 365*6/12, # bandwidth di 6 mesi oppure bw$bw
data = data)
preds=predict(m_loc,newdata=grid_time_num,se=T)
se.bands=cbind(preds$fit +2* preds$se.fit ,preds$fit -2* preds$se.fit)
funct_data = cbind(funct_data,preds$fit)
}
rm(nh, data,m_loc,preds,se.bands,ind_nh)
colnames(funct_data) = list_nhood
dim(funct_data)
length(grid_time)
library(roahd)
funz_rent = funct_data
funct_data = fData(grid_time,t(funct_data))
x11()
plot(funct_data, xlab = 'Year', ylab = 'Price/mq', main = 'Smoothed rent functions')
#Calcolo derivate prime
diff_rent = funz_rent[2:dim(funz_rent)[1],] - funz_rent[1:dim(funz_rent)[1]-1,]
dim(funz_rent)
dim(diff_rent)
funct_data_diff = fData(grid_time[2:length(grid_time)], t(diff_rent))
x11()
plot(funct_data_diff, xlab = 'Year', ylab = 'd/dt(Price/mq)', main = 'Approximation of first derivative of rent functions')
}
library(fdatest)
#NB: data si assume con tempo sulle righe e nomi sulle colonne
data = funz_rent #cambiare con funz_rent per fare i test sulle funzioni dei rent e non derivate!
low_evictions_nhood2 <- read_csv("2 Clusters of nhood based on Evictions/low_evictions_nhood_nh2.csv")
high_evictions_nhood2 <- read_csv("2 Clusters of nhood based on Evictions/high_evictions_nhood_nh2.csv")
low_construction_nhood2_nh <- read_csv("2 Clusters of nhood based on Constructions/low_construction_nhood2_nh.csv")
high_construction_nhood2_nh <- read_csv("2 Clusters of nhood based on Constructions/high_construction_nhood2_nh.csv")
list_low_constr = as.vector(low_construction_nhood2_nh$x)
list_low_constr = list_low_constr[-c(5,7)] #tolgo i nhood non osservati in rent
list_high_constr = as.vector(high_construction_nhood2_nh$x)
list_high_constr = list_high_constr[-c(3,10)]
list_low_evict = as.vector(low_evictions_nhood2$x)
list_high_evict = as.vector(high_evictions_nhood2$x)
list_low_evict = list_low_evict[-c(4,6,7,8,12,16)]#non ci sono osservazioni negli annunci di questi quindi rimuovo
list_high_evict = list_high_evict[-c(3,7)] #non ci sono osservazioni negli annunci quindi tolgo
data1 = data[,list_low_constr]
data2 = data[,list_high_constr]
#data1 = data[,1:23]
#data2 = data[,24:46]
data_bind = rbind(t(data1),t(data2)) #data_bind ha nomi sulle righe!
n = nrow(data_bind)
n1 = nrow(t(data1)) #numero nomi in gruppo1
n2 = nrow(t(data2)) #numero nomi in gruppo2
data1 = fData(grid_time,t(data1)) #partizione di quartieri 1, NB: mettere grid_time se si testano funzioni dei rent
data2 = fData(grid_time,t(data2)) #partizione di quartieri 2, NB: mettere grid_time se si testano funzioni dei rent
seed=2781991
set.seed(seed)
B=1000
mean_diff = median_fData(data1, type = 'MBD') - median_fData(data2, type = 'MBD')
plot(mean_diff)
T0 = sum(abs(mean_diff$values))
T0
data_fd = append_fData(data1,data2)
T0_perm = numeric(B)
x11()
plot(data1, col = 'red', xlab = 'Year', ylab = 'Price/mq',ylim = c(15,70), main = 'Rent functions')
plot(data2, col = 'black', add = T)
legend('topleft', legend=c("Low evictions", "High evictions"),
col=c("red", "black"),lty = 1, cex=0.8)
library(progress)
pb <- progress_bar$new(format = "  processing [:bar] :percent eta: :eta",total = B, clear = FALSE)
for(perm in 1:B){
permutazione <- sample(n)
data_perm=data_fd[permutazione,]
perm1 = data_perm[1:n1,]
perm2 = data_perm[(n2+1):n,]
mean_diff=median_fData(perm1,type='MBD')-median_fData(perm2,type='MBD')
T0_perm[perm]=sum(abs(mean_diff$values))
pb$tick()
}
sum(T0_perm >= T0)/B
Parcels <- read.csv("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/Original Datasets/Parcels.csv", header=TRUE)
Parcels <- read.csv("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/Original Datasets/Parcels.csv", header=TRUE)
Parcels <- read.csv("C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/Original Datasets/Parcels.csv", header=TRUE)
View(Parcels)
Parcels <- Parcels[,c(3,7:10)]
View(Parcels)
write.csv(Parcels,"C:/Users/Pietro/Desktop/Pietro/Politecnico/Magistrale/Nonparametric_Statistics/Progetto/ricerca di progetti/Progetto Case SF/SF-houses/Parcels_poly.csv",row.names=FALSE)
